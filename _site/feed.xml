<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-06-02T00:04:07-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Edward Wawrzynek</title><subtitle>Hello. I&apos;m a student at CU Boulder with interests in applied electromagnetics and radio frequency electronics.</subtitle><entry><title type="html">FDTD wave equation solver</title><link href="http://localhost:4000/2024/05/28/fdtd-wave-equation.html" rel="alternate" type="text/html" title="FDTD wave equation solver" /><published>2024-05-28T00:00:00-06:00</published><updated>2024-05-28T00:00:00-06:00</updated><id>http://localhost:4000/2024/05/28/fdtd-wave-equation</id><content type="html" xml:base="http://localhost:4000/2024/05/28/fdtd-wave-equation.html"><![CDATA[<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<p><img src="/images/2024-05-28-fdtd-wave-equation/app.png" /></p>

<p>I developed a GPU accelerated finite difference time domain (FDTD) solver for the wave equation and a graphical interface to construct boundary conditions and visualize solutions in real time. The description below gives a brief introduction to the FDTD method, a practical implementation and some example systems. The solver and it’s graphical interface can be <a href="https://github.com/edwardwawrzynek/waves_sim">found on github</a>.</p>

<h1 id="introduction">Introduction</h1>

<p>The wave equation is a second order PDE appearing in the description of a wide range of physical systems. It describes the propagation of disturbances (waves) in both mechanic systems and electromagnetic waves in free space.</p>

<p>We consider some scalar field \(u(\textbf{x}, t)\) which describes the system of interest. In a mechanical system, \(u\) might describe displacement of a solid or fluid. In electromagnetics, \(u\) might be a component of the electric field. For such a scalar system, the wave equation is</p>

\[\nabla^2 u - \frac{1}{c^2} \frac{\partial^2 u}{\partial^2 t} = 0, \tag{1}\]

<p>where \(c\) is some positive real coefficient that may vary with space. It describes the speed of the waves in the system and is related to the properties of the media in which propagation occurs.</p>

<p>Our goal is to efficiently find numerical solutions to this equation subject to arbitrary boundary conditions.</p>

<h1 id="fdtd">FDTD</h1>

<p>We implement the finite difference time domain (FDTD) method described by Yee <a href="#ref1">[1]</a>. The solver is implemented with OpenGL. To allow for a simple graphical interface to specify boundary conditions and media properties, we only consider 2 dimensional systems.</p>

<p>In order to perform numerical computations, we must discretize \(u\) in both space and time. We consider a grid with physical spacing \(\Delta x\) and timesteps \(\Delta t\). We are only interested in the value of \(u\) at these points, which we denote as</p>

\[u_{i,j}^n = u(i\Delta x, j\Delta x, n\Delta t).\]

<p>We need a way to numerical approximate the derivatives involved in the wave equation. For the spacial derivative in the x direction, we can simply use the second symmetric derivative,</p>

\[\frac{\partial^2 u}{\partial^2 x} = \lim_{h \to 0} \frac{u(x + h, y, t) - 2u(x, y, t) + u(x - h, y, t)}{h^2} \approx \frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{\Delta x^2},\]

<p>with a similar result in the y direction,</p>

\[\frac{\partial^2 u}{\partial^2 y} \approx \frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{\Delta x^2},\]

<p>giving the combined Laplacian</p>

\[\nabla^2 u = \frac{\partial^2 u}{\partial^2 x} + \frac{\partial^2 u}{\partial^2 y} \approx \frac{u_{i+1,j}^n + u_{i,j+1}^n - 4u_{i,j}^n + u_{i-1,j}^n + u_{i,j-1}^n}{\Delta x^2}. \tag{2}\]

<p>The time derivative in the wave equation presents more trouble. Because the simulation is performed in the time domain, we know only \(u_{i,j}^n\) for \(n &lt; N\), where \(N\) is the current time step. We can decompose the wave equation into two coupled PDEs which are first order in time, that is,</p>

\[\begin{align} \frac{\partial u}{\partial t} &amp;= u', \tag{3} \\ \frac{\partial u'}{\partial t} &amp;= c^2 \nabla^2 u. \tag{4} \end{align}\]

<p>We can approximate the first PDE \((3)\) with the limit definition as</p>

\[u' = \lim_{h \to 0} \frac{u(x,y,t+h) - u(x,y,t)}{h} \approx \frac{u_{i,j}^{n+1} - u_{i,j}^n}{\Delta t},\]

<p>which we rearrange to yield</p>

\[u_{i,j}^{n+1} = u_{i,j}^n + \left(\Delta t\right) u{'}_{i,j}^{n}.\]

<p>Similarly, for the second PDE \((4)\) we have</p>

\[\frac{\partial u'}{\partial t} = \frac{u{'}_{i,j}^{n} - u{'}_{i,j}^{n-1}}{\Delta t} = c^2 \nabla^2 u.\]

<p>Rearranging, we can isolate the term for the current state of the system, \(u{'}^{n}\), and have</p>

\[u{'}_{i,j}^{n} = u{'}_{i,j}^{n-1} + \left(\Delta t\right) c^2 \nabla^2 u.\]

<p>Combining with \((2)\), we have the system</p>

\[\begin{align} u{'}_{i,j}^{n} &amp;= u{'}_{i,j}^{n-1} + \frac{\Delta t}{\Delta x^2}\left(u_{i+1,j}^n + u_{i,j+1}^n - 4u_{i,j}^n + u_{i-1,j}^n + u_{i,j-1}^n\right), \tag{5}\\
u_{i,j}^{n+1} &amp;= u_{i,j}^n + \left(\Delta t\right) u{'}_{i,j}^{n}, \tag{6}\end{align}\]

<p>which we can easily solve via iteration. We initialize \(u^2_{i,j}\) and \(u{'}^1_{i,j}\) from initial conditions. For \(n \geq 2\), each round of iteration consists of two steps:</p>
<ol>
  <li>update \(u'\) from \((5)\), and</li>
  <li>update \(u\) from \((6)\) using the just computed \(u'\).</li>
</ol>

<h1 id="boundary-conditions">Boundary Conditions</h1>

<p>The solver supports both Dirichlet (\(u = 0\)) and Neumann (\(\frac{\partial u}{\partial x} = 0\) or \(\frac{\partial u}{\partial y} = 0\)) boundary conditions. The Dirichlet condition can be implemented by setting \(u_{i,j}^n = 0\) at each round of iteration. The Neumann condition can be implemented by fixing \(u_{i,j}^n\) to match its appropriate neighbor—one of \(u_{i-1,j}^n\), \(u_{i+1,j}^n\), \(u_{i,j-1}^n\), or \(u_{i,j+1}^n\), depending on the orientation of the surface on which the boundary condition is imposed.</p>

<h1 id="boundary-layer">Boundary Layer</h1>

<p>The discretization grid is bound over some finite domain \((i, j) \in [0, I] \times [0, J]\). At the edges of that domain, we cannot evaluate \((2)\) and instead have to apply some boundary condition. Ideally, we would like disturbances which reach the edge of the domain to be absorbed. Unfortunately, both the Dirichlet and Neumann boundary conditions lead to reflection rather than absorption, shown in Figure 1.</p>

<center>
    <video width="400" height="400" controls="">
        <source src="/images/2024-05-28-fdtd-wave-equation/no_boundary.webm" type="video/webm" />
        Video not supported.
    </video>

    <p>Figure 1: Wave propagation with Dirichlet boundary condition at the edge of the simulation domain. The wave reflects off the edges, creating a standing wave pattern.</p>
</center>

<p>One way to implement absorption is with a layer near the edge of the domain over which we damp the response of \(u\) <a href="#ref2">[2]</a>. We define a damping function</p>

\[\sigma(d) = \tan^{-1}\left(\frac{2d}{D} + 1\right),\]

<p>where \(d\) is the distance from the edge of the domain and \(D\) is the width of the absorbing layer. The function approaches 0 near the edge of the domain. In the layer, we modify the iteration step \((6)\) to include damping,</p>

\[u_{i,j}^{n+1} = \sigma(i,j)u_{i,j}^n + \left(\Delta t\right) u{'}_{i,j}^{n}. \tag{7}\]

<p>The damping term dissipates energy in the wave while providing a smooth impedance discontinuity to minimize reflections near the boundary.</p>

<center>
    <video width="400" height="400" controls="">
        <source src="/images/2024-05-28-fdtd-wave-equation/boundary.webm" type="video/webm" />
        Video not supported.
    </video>

    <p>Figure 2: Wave propagation with an absorbing boundary layer. The white lines indicate the edge of the layer. The wave is almost fully damped before reaching the edge of the simulation domain.</p>
</center>

<h1 id="implementation">Implementation</h1>

<p>The algorithm described above is implemented in a GLSL fragment shader. The shader operates on a single texture, with the following channels:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">.x</code> - \(u_{i,j}^{n}\),</li>
  <li><code class="language-plaintext highlighter-rouge">.y</code> - \(u{'}_{i,j}^{n}\),</li>
  <li><code class="language-plaintext highlighter-rouge">.z</code> - \(c_{i,j},\) the value of wave speed at the given point,</li>
  <li><code class="language-plaintext highlighter-rouge">.w</code> - boundary conditions (0 for no condition, 1 for a Neumann condition).</li>
</ol>

<p>The evaluation of the Laplacian follows \((2)\) and is given below.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// calculate the new u_tt value for a point based on its neighbors</span>
<span class="kt">float</span> <span class="nf">calc_wave_eq</span><span class="p">(</span><span class="kt">ivec2</span> <span class="n">point</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u_point</span><span class="p">,</span> <span class="kt">float</span> <span class="n">wave_speed</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// get neighbors and calculate laplacian (via second symmetric derivative)</span>
    <span class="kt">float</span> <span class="n">u0</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">(</span><span class="kt">ivec2</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">u_point</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">u1</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">(</span><span class="kt">ivec2</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">u_point</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">(</span><span class="kt">ivec2</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">u_point</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">u3</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">(</span><span class="kt">ivec2</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">u_point</span><span class="p">);</span>

    <span class="kt">float</span> <span class="n">laplace</span> <span class="o">=</span> <span class="p">(</span><span class="n">u0</span> <span class="o">+</span> <span class="n">u1</span> <span class="o">+</span> <span class="n">u2</span> <span class="o">+</span> <span class="n">u3</span> <span class="o">-</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">u_point</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">delta_x</span> <span class="o">*</span> <span class="n">delta_x</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">wave_speed</span> <span class="o">*</span> <span class="n">wave_speed</span> <span class="o">*</span> <span class="n">laplace</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Calculation of the damping function \(\sigma(i,j)\) is given below.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return damping factor for a point</span>
<span class="kt">float</span> <span class="nf">damping</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">point</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">ivec2</span> <span class="n">tex_size</span> <span class="o">=</span> <span class="n">textureSize</span><span class="p">(</span><span class="n">sim_texture</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// get distance from point to closest edge</span>
    <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> 
      <span class="n">min</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">tex_size</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="kt">float</span><span class="p">(</span><span class="n">tex_size</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">damping_area_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">damping_area_size</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">tanh</span><span class="p">(</span><span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">norm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The main iteration loop follows \((5)\) and \((7)\) and is given below.</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">vec4</span> <span class="n">point</span> <span class="o">=</span> <span class="n">texelFetch</span><span class="p">(</span><span class="n">sim_texture</span><span class="p">,</span> <span class="kt">ivec2</span><span class="p">(</span><span class="nb">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">u</span> <span class="o">=</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">u_t</span> <span class="o">=</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ior_inv</span> <span class="o">=</span> <span class="n">point</span><span class="p">.</span><span class="n">z</span><span class="p">;</span> <span class="c1">// inverse index of refraction</span>

    <span class="kt">float</span> <span class="n">u_tt</span> <span class="o">=</span> <span class="n">calc_wave_eq</span><span class="p">(</span><span class="kt">ivec2</span><span class="p">(</span><span class="nb">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span> <span class="n">u</span><span class="p">,</span> 
      <span class="n">ior_inv</span> <span class="o">*</span> <span class="n">wave_speed_vacuum</span><span class="p">);</span>

    <span class="n">u_t</span> <span class="o">+=</span> <span class="n">u_tt</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">;</span>
    <span class="n">u_t</span> <span class="o">*=</span> <span class="n">damping</span><span class="p">(</span><span class="nb">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>

    <span class="n">u</span> <span class="o">+=</span> <span class="n">u_t</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">;</span>

    <span class="n">color</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_t</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="examples">Examples</h1>
<h4 id="double-slit">Double Slit</h4>

<p>A plane wave incident on two small slits with a small separation demonstrates a <a href="https://en.wikipedia.org/wiki/Double-slit_experiment">double-slit pattern</a>. When the plane wave passes through the slits, the resulting light diffracts, forming hemispherical wavefronts radiating from each slit. Interference between the two wavefronts creates the diffraction pattern.</p>

<center>
    <video width="400" height="400" controls="">
        <source src="/images/2024-05-28-fdtd-wave-equation/double_slit.webm" type="video/webm" />
        Video not supported.
    </video>

    <p>Figure 3: Double slit interference.</p>
</center>

<h4 id="impedance-mismatch">Impedance Mismatch</h4>

<p>A plane wave incident on two media with varying refractive indexes produces both a transmitted wave and a reflection. The extend of mismatch between the media results in a differing distribution of power between the transmitted and reflected wave. Additionally, the speed of wave propagation changes in the different media.</p>

<p>The circular wavefronts that appear to reflect off the corner between the three media are due to diffraction.</p>

<center>
    <video width="400" height="400" controls="">
        <source src="/images/2024-05-28-fdtd-wave-equation/impedance_mismatch.webm" type="video/webm" />
        Video not supported.
    </video>

    <p>Figure 4: Reflection and transmission of a plane wave across an impedance mismatch. The medium in the lower left has the highest refractive index, followed by the medium in the lower right and the free space in the upper region. </p>
</center>

<h4 id="total-internal-reflection">Total Internal Reflection</h4>

<p>A plane wave incident on a media at an angle greater than the Brewster angle produces <a href="https://en.wikipedia.org/wiki/Total_internal_reflection">total internal reflection</a>, with little transmission.</p>

<center>
    <video width="400" height="400" controls="">
        <source src="/images/2024-05-28-fdtd-wave-equation/tir.webm" type="video/webm" />
        Video not supported.
    </video>

    <p>Figure 5: Total internal reflection. </p>
</center>

<h4 id="doppler-effect">Doppler Effect</h4>

<p>A moving source causes an apparent change in frequency along the direction of motion, the <a href="https://en.wikipedia.org/wiki/Doppler_effect">doppler effect</a>.</p>

<center>
    <video width="400" height="400" controls="">
        <source src="/images/2024-05-28-fdtd-wave-equation/doppler.webm" type="video/webm" />
        Video not supported.
    </video>

    <p>Figure 6: Doppler effect with a source moving at 75% of the wave speed. </p>
</center>

<center>
    <video width="400" height="400" controls="">
        <source src="/images/2024-05-28-fdtd-wave-equation/doppler_boom.webm" type="video/webm" />
        Video not supported.
    </video>

    <p>Figure 7: Shockwave created by a source moving at 200% of the wave speed. </p>
</center>

<h4 id="straight-vs-mitered-bends-in-a-waveguide">Straight vs Mitered Bends in a Waveguide</h4>

<p>A wave encounters a bend section of waveguide, shown in Figure 6. The guide with the straight bend has a larger impedance discontinuity, resulting in lower transmission. The guide with a mitered bend has a smaller discontinuity, resulting in larger transmission. The amount of transmission through the line can be measured by the intensity of the field at the open end of the guide.</p>

<center>
    <video width="400" height="400" controls="">
        <source src="/images/2024-05-28-fdtd-wave-equation/pcb_tl.webm" type="video/webm" />
        Video not supported.
    </video>

    <p>Figure 8: Wave propagation across two bends in a waveguide.</p>
</center>

<h4 id="phased-array">Phased Array</h4>

<p>A phased array constructed from 8 sources located \(\lambda/4\) away from each other has a variable phase delay between elements, creating a steerable beam.</p>

<center>
    <video width="400" height="400" controls="">
        <source src="/images/2024-05-28-fdtd-wave-equation/phased_array.webm" type="video/webm" />
        Video not supported.
    </video>

    <p>Figure 8: An 8 element phased array sweeping from -60 to 60 degrees.</p>
</center>

<h1 id="references">References</h1>

<p><span id="ref1">[1] Kane Yee, “Numerical solution of initial boundary value problems involving maxwell’s equations in isotropic media,” in IEEE Transactions on Antennas and Propagation, vol. 14, no. 3, pp. 302-307, May 1966, doi: <a href="https://doi.org/10.1109%2FTAP.1966.1138693">10.1109/TAP.1966.1138693</a>.</span></p>

<p><span id="ref2">[2] Jean-Pierre Berenger,
“A perfectly matched layer for the absorption of electromagnetic waves,”
in Journal of Computational Physics,
vol. 114, no. 2,
pp 185-200,
1994,
doi: <a href="https://doi.org/10.1006/jcph.1994.1159">10.1006/jcph.1994.1159</a>. </span></p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Fractal Explorer</title><link href="http://localhost:4000/2024/05/27/fractal-explorer.html" rel="alternate" type="text/html" title="Fractal Explorer" /><published>2024-05-27T00:00:00-06:00</published><updated>2024-05-27T00:00:00-06:00</updated><id>http://localhost:4000/2024/05/27/fractal-explorer</id><content type="html" xml:base="http://localhost:4000/2024/05/27/fractal-explorer.html"><![CDATA[<p><a href="http://fractal.wawrzynek.com">Go to fractal explorer.</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Go to fractal explorer.]]></summary></entry></feed>